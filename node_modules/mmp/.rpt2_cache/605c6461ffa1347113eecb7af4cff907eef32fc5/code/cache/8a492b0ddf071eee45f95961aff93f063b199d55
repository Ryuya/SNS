{"code":"import * as d3 from \"d3\";\r\nimport { Event } from \"./events\";\r\n/**\r\n * Manage the drag events of the nodes.\r\n */\r\nvar Drag = /** @class */ (function () {\r\n    /**\r\n     * Get the associated map instance and initialize the d3 drag behavior.\r\n     * @param {Map} map\r\n     */\r\n    function Drag(map) {\r\n        var _this = this;\r\n        this.map = map;\r\n        this.dragBehavior = d3.drag()\r\n            .on(\"start\", function (node) { return _this.started(node); })\r\n            .on(\"drag\", function (node) { return _this.dragged(node); })\r\n            .on(\"end\", function (node) { return _this.ended(node); });\r\n    }\r\n    /**\r\n     * Return the d3 drag behavior\r\n     * @returns {DragBehavior} dragBehavior\r\n     */\r\n    Drag.prototype.getDragBehavior = function () {\r\n        return this.dragBehavior;\r\n    };\r\n    /**\r\n     * Select the node and calculate node position data for dragging.\r\n     * @param {Node} node\r\n     */\r\n    Drag.prototype.started = function (node) {\r\n        d3.event.sourceEvent.preventDefault();\r\n        this.orientation = this.map.nodes.getOrientation(node);\r\n        this.descendants = this.map.nodes.getDescendants(node);\r\n        this.map.nodes.selectNode(node.id);\r\n    };\r\n    /**\r\n     * Move the dragged node and if it is locked all their descendants.\r\n     * @param {Node} node\r\n     */\r\n    Drag.prototype.dragged = function (node) {\r\n        var _this = this;\r\n        var dy = d3.event.dy, dx = d3.event.dx;\r\n        // Set new coordinates\r\n        var x = node.coordinates.x += dx, y = node.coordinates.y += dy;\r\n        // Move graphically the node in new coordinates\r\n        node.dom.setAttribute(\"transform\", \"translate(\" + [x, y] + \")\");\r\n        // If the node is locked move also descendants\r\n        if (node.locked) {\r\n            // Check if old and new orientation are equal\r\n            var newOrientation = this.map.nodes.getOrientation(node), orientationIsChanged = newOrientation !== this.orientation, root = node;\r\n            for (var _i = 0, _a = this.descendants; _i < _a.length; _i++) {\r\n                var node_1 = _a[_i];\r\n                var x_1 = node_1.coordinates.x += dx, y_1 = node_1.coordinates.y += dy;\r\n                if (orientationIsChanged) {\r\n                    x_1 = node_1.coordinates.x += (root.coordinates.x - node_1.coordinates.x) * 2;\r\n                }\r\n                node_1.dom.setAttribute(\"transform\", \"translate(\" + [x_1, y_1] + \")\");\r\n            }\r\n            if (orientationIsChanged) {\r\n                this.orientation = newOrientation;\r\n            }\r\n        }\r\n        // Update all mind map branches\r\n        d3.selectAll(\".\" + this.map.id + \"_branch\").attr(\"d\", function (node) {\r\n            return _this.map.draw.drawBranch(node);\r\n        });\r\n        // This is here and not in the started function because started function\r\n        // is also executed when there is no drag events\r\n        this.dragging = true;\r\n    };\r\n    /**\r\n     * If the node was actually dragged change the state of dragging and save the snapshot.\r\n     * @param {Node} node\r\n     */\r\n    Drag.prototype.ended = function (node) {\r\n        if (this.dragging) {\r\n            this.dragging = false;\r\n            this.map.history.save();\r\n            this.map.events.call(Event.nodeUpdate, node.dom, this.map.nodes.getNodeProperties(node));\r\n        }\r\n    };\r\n    return Drag;\r\n}());\r\nexport default Drag;\r\n"}
