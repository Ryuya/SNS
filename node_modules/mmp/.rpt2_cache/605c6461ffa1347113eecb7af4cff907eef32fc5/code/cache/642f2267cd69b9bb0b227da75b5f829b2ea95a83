{"code":"import Node from \"../models/node\";\r\nimport * as d3 from \"d3\";\r\nimport { Event } from \"./events\";\r\nimport Log from \"../../utils/log\";\r\nimport Utils from \"../../utils/utils\";\r\n/**\r\n * Manage the nodes of the map.\r\n */\r\nvar Nodes = /** @class */ (function () {\r\n    /**\r\n     * Get the associated map instance and initialize counter and nodes.\r\n     * @param {Map} map\r\n     */\r\n    function Nodes(map) {\r\n        var _this = this;\r\n        /**\r\n         * Add a node in the map.\r\n         * @param {UserNodeProperties} userProperties\r\n         * @param {string} id\r\n         */\r\n        this.addNode = function (userProperties, id) {\r\n            if (id && typeof id !== \"string\") {\r\n                Log.error(\"The node id must be a string\", \"type\");\r\n            }\r\n            var parentNode = id ? _this.getNode(id) : _this.selectedNode;\r\n            if (parentNode === undefined) {\r\n                Log.error(\"There are no nodes with id \\\"\" + id + \"\\\"\");\r\n            }\r\n            var properties = Utils.mergeObjects(_this.map.options.defaultNode, userProperties, true);\r\n            properties.id = _this.map.id + \"_node_\" + _this.counter;\r\n            properties.parent = parentNode;\r\n            var node = new Node(properties);\r\n            _this.nodes.set(properties.id, node);\r\n            _this.counter++;\r\n            // Set coordinates\r\n            node.coordinates = _this.calculateCoordinates(node);\r\n            if (userProperties && userProperties.coordinates) {\r\n                var fixedCoordinates = _this.fixCoordinates(userProperties.coordinates);\r\n                node.coordinates = Utils.mergeObjects(node.coordinates, fixedCoordinates, true);\r\n            }\r\n            _this.map.draw.update();\r\n            _this.map.history.save();\r\n            _this.map.events.call(Event.nodeCreate, node.dom, _this.getNodeProperties(node));\r\n        };\r\n        /**\r\n         * Select a node or return the current selected node.\r\n         * @param {string} id\r\n         * @returns {ExportNodeProperties}\r\n         */\r\n        this.selectNode = function (id) {\r\n            if (id !== undefined) {\r\n                if (typeof id !== \"string\") {\r\n                    Log.error(\"The node id must be a string\", \"type\");\r\n                }\r\n                if (!_this.nodeSelectionTo(id)) {\r\n                    if (_this.nodes.has(id)) {\r\n                        var node = _this.nodes.get(id), background = node.getBackgroundDOM();\r\n                        if (!background.style.stroke) {\r\n                            if (_this.selectedNode) {\r\n                                _this.selectedNode.getBackgroundDOM().style.stroke = \"\";\r\n                            }\r\n                            var color = d3.color(background.style.fill).darker(.5);\r\n                            background.style.stroke = color.toString();\r\n                            Utils.removeAllRanges();\r\n                            _this.selectedNode.getNameDOM().blur();\r\n                            _this.selectedNode = node;\r\n                            _this.map.events.call(Event.nodeSelect, node.dom, _this.getNodeProperties(node));\r\n                        }\r\n                    }\r\n                    else {\r\n                        Log.error(\"The node id or the direction is not correct\");\r\n                    }\r\n                }\r\n            }\r\n            return _this.getNodeProperties(_this.selectedNode);\r\n        };\r\n        /**\r\n         * Enable the node name editing of the selected node.\r\n         */\r\n        this.editNode = function () {\r\n            if (_this.selectedNode) {\r\n                _this.map.draw.enableNodeNameEditing(_this.selectedNode);\r\n            }\r\n        };\r\n        /**\r\n         * Deselect the current selected node.\r\n         */\r\n        this.deselectNode = function () {\r\n            if (_this.selectedNode) {\r\n                _this.selectedNode.getBackgroundDOM().style.stroke = \"\";\r\n                Utils.removeAllRanges();\r\n            }\r\n            _this.selectRootNode();\r\n            _this.map.events.call(Event.nodeDeselect);\r\n        };\r\n        /**\r\n         * Update the properties of the selected node.\r\n         * @param {string} property\r\n         * @param value\r\n         * @param {string} id\r\n         * @param {boolean} graphic\r\n         */\r\n        this.updateNode = function (property, value, graphic, id) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (id && typeof id !== \"string\") {\r\n                Log.error(\"The node id must be a string\", \"type\");\r\n            }\r\n            var node = id ? _this.getNode(id) : _this.selectedNode;\r\n            if (node === undefined) {\r\n                Log.error(\"There are no nodes with id \\\"\" + id + \"\\\"\");\r\n            }\r\n            if (typeof property !== \"string\") {\r\n                Log.error(\"The property must be a string\", \"type\");\r\n            }\r\n            var updated;\r\n            switch (property) {\r\n                case \"name\":\r\n                    updated = _this.updateNodeName(_this.selectedNode, value, graphic);\r\n                    break;\r\n                case \"locked\":\r\n                    updated = _this.updateNodeLockedStatus(_this.selectedNode, value);\r\n                    break;\r\n                case \"coordinates\":\r\n                    updated = _this.updateNodeCoordinates(_this.selectedNode, value);\r\n                    break;\r\n                case \"imageSrc\":\r\n                    updated = _this.updateNodeImageSrc(_this.selectedNode, value);\r\n                    break;\r\n                case \"imageSize\":\r\n                    updated = _this.updateNodeImageSize(_this.selectedNode, value, graphic);\r\n                    break;\r\n                case \"backgroundColor\":\r\n                    updated = _this.updateNodeBackgroundColor(_this.selectedNode, value, graphic);\r\n                    break;\r\n                case \"branchColor\":\r\n                    updated = _this.updateNodeBranchColor(_this.selectedNode, value, graphic);\r\n                    break;\r\n                case \"fontWeight\":\r\n                    updated = _this.updateNodeFontWeight(_this.selectedNode, value, graphic);\r\n                    break;\r\n                case \"textDecoration\":\r\n                    updated = _this.updateNodeTextDecoration(_this.selectedNode, value, graphic);\r\n                    break;\r\n                case \"fontStyle\":\r\n                    updated = _this.updateNodeFontStyle(_this.selectedNode, value, graphic);\r\n                    break;\r\n                case \"fontSize\":\r\n                    updated = _this.updateNodeFontSize(_this.selectedNode, value, graphic);\r\n                    break;\r\n                case \"nameColor\":\r\n                    updated = _this.updateNodeNameColor(_this.selectedNode, value, graphic);\r\n                    break;\r\n                default:\r\n                    Log.error(\"The property does not exist\");\r\n            }\r\n            if (graphic === false && updated !== false) {\r\n                _this.map.history.save();\r\n                _this.map.events.call(Event.nodeUpdate, _this.selectedNode.dom, _this.getNodeProperties(_this.selectedNode));\r\n            }\r\n        };\r\n        /**\r\n         * Remove the selected node.\r\n         * @param {string} id\r\n         */\r\n        this.removeNode = function (id) {\r\n            if (id && typeof id !== \"string\") {\r\n                Log.error(\"The node id must be a string\", \"type\");\r\n            }\r\n            var node = id ? _this.getNode(id) : _this.selectedNode;\r\n            if (node === undefined) {\r\n                Log.error(\"There are no nodes with id \\\"\" + id + \"\\\"\");\r\n            }\r\n            if (!node.isRoot()) {\r\n                _this.nodes.remove(node.id);\r\n                _this.getDescendants(node).forEach(function (node) {\r\n                    _this.nodes.remove(node.id);\r\n                });\r\n                _this.map.draw.clear();\r\n                _this.map.draw.update();\r\n                _this.map.history.save();\r\n                _this.map.events.call(Event.nodeRemove, null, _this.getNodeProperties(node));\r\n                _this.deselectNode();\r\n            }\r\n            else {\r\n                Log.error(\"The root node can not be deleted\");\r\n            }\r\n        };\r\n        /**\r\n         * Return the children of the node.\r\n         * @param {string} id\r\n         * @returns {ExportNodeProperties[]}\r\n         */\r\n        this.nodeChildren = function (id) {\r\n            if (id && typeof id !== \"string\") {\r\n                Log.error(\"The node id must be a string\", \"type\");\r\n            }\r\n            var node = id ? _this.getNode(id) : _this.selectedNode;\r\n            if (node === undefined) {\r\n                Log.error(\"There are no nodes with id \\\"\" + id + \"\\\"\");\r\n            }\r\n            return _this.nodes.values().filter(function (n) {\r\n                return n.parent && n.parent.id === node.id;\r\n            }).map(function (n) {\r\n                return _this.getNodeProperties(n);\r\n            });\r\n        };\r\n        /**\r\n         * Update the node name with a new value.\r\n         * @param {Node} node\r\n         * @param {string} name\r\n         * @param {boolean} graphic\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeName = function (node, name, graphic) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (name && typeof name !== \"string\") {\r\n                Log.error(\"The name must be a string\", \"type\");\r\n            }\r\n            if (node.name != name || graphic) {\r\n                node.getNameDOM().innerHTML = name;\r\n                _this.map.draw.updateNodeShapes(node);\r\n                if (graphic === false) {\r\n                    node.name = name;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Update the node coordinates with a new value.\r\n         * @param {Node} node\r\n         * @param {Coordinates} coordinates\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeCoordinates = function (node, coordinates) {\r\n            var fixedCoordinates = _this.fixCoordinates(coordinates);\r\n            coordinates = Utils.mergeObjects(node.coordinates, fixedCoordinates, true);\r\n            if (!(coordinates.x === node.coordinates.x && coordinates.y === node.coordinates.y)) {\r\n                var oldOrientation = _this.getOrientation(_this.selectedNode), dx = node.coordinates.x - coordinates.x, dy = node.coordinates.y - coordinates.y;\r\n                node.coordinates = Utils.cloneObject(coordinates);\r\n                node.dom.setAttribute(\"transform\", \"translate(\" + [coordinates.x, coordinates.y] + \")\");\r\n                // If the node is locked move also descendants\r\n                if (_this.selectedNode.locked) {\r\n                    var root = _this.selectedNode, descendants = _this.getDescendants(_this.selectedNode), newOrientation = _this.getOrientation(_this.selectedNode);\r\n                    for (var _i = 0, descendants_1 = descendants; _i < descendants_1.length; _i++) {\r\n                        var node_1 = descendants_1[_i];\r\n                        var x = node_1.coordinates.x -= dx, y = node_1.coordinates.y -= dy;\r\n                        if (oldOrientation !== newOrientation) {\r\n                            x = node_1.coordinates.x += (root.coordinates.x - node_1.coordinates.x) * 2;\r\n                        }\r\n                        node_1.dom.setAttribute(\"transform\", \"translate(\" + [x, y] + \")\");\r\n                    }\r\n                }\r\n                d3.selectAll(\".\" + _this.map.id + \"_branch\").attr(\"d\", function (node) {\r\n                    return _this.map.draw.drawBranch(node);\r\n                });\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Update the node background color with a new value.\r\n         * @param {Node} node\r\n         * @param {string} color\r\n         * @param {boolean} graphic\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeBackgroundColor = function (node, color, graphic) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (color && typeof color !== \"string\") {\r\n                Log.error(\"The background color must be a string\", \"type\");\r\n            }\r\n            if (node.colors.background !== color || graphic) {\r\n                var background = node.getBackgroundDOM();\r\n                background.style[\"fill\"] = color;\r\n                if (background.style[\"stroke\"] !== \"\") {\r\n                    background.style[\"stroke\"] = d3.color(color).darker(.5).toString();\r\n                }\r\n                if (graphic === false) {\r\n                    node.colors.background = color;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Update the node text color with a new value.\r\n         * @param {Node} node\r\n         * @param {string} color\r\n         * @param {boolean} graphic\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeNameColor = function (node, color, graphic) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (color && typeof color !== \"string\") {\r\n                Log.error(\"The text color must be a string\", \"type\");\r\n            }\r\n            if (node.colors.name !== color || graphic) {\r\n                node.getNameDOM().style[\"color\"] = color;\r\n                if (graphic === false) {\r\n                    node.colors.name = color;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Update the node branch color with a new value.\r\n         * @param {Node} node\r\n         * @param {string} color\r\n         * @param {boolean} graphic\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeBranchColor = function (node, color, graphic) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (color && typeof color !== \"string\") {\r\n                Log.error(\"The branch color must be a string\", \"type\");\r\n            }\r\n            if (!node.isRoot()) {\r\n                if (node.colors.name !== color || graphic) {\r\n                    var branch = document.getElementById(node.id + \"_branch\");\r\n                    branch.style[\"fill\"] = branch.style[\"stroke\"] = color;\r\n                    if (graphic === false) {\r\n                        node.colors.branch = color;\r\n                    }\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                Log.error(\"The root node has no branches\");\r\n            }\r\n        };\r\n        /**\r\n         * Update the node font size with a new value.\r\n         * @param {Node} node\r\n         * @param {number} size\r\n         * @param {boolean} graphic\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeFontSize = function (node, size, graphic) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (size && typeof size !== \"number\") {\r\n                Log.error(\"The font size must be a number\", \"type\");\r\n            }\r\n            if (node.font.size != size || graphic) {\r\n                node.getNameDOM().style[\"font-size\"] = size + \"px\";\r\n                _this.map.draw.updateNodeShapes(node);\r\n                if (graphic === false) {\r\n                    node.font.size = size;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Update the node image size with a new value.\r\n         * @param {Node} node\r\n         * @param {number} size\r\n         * @param {boolean} graphic\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeImageSize = function (node, size, graphic) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (size && typeof size !== \"number\") {\r\n                Log.error(\"The image size must be a number\", \"type\");\r\n            }\r\n            if (node.image.src !== \"\") {\r\n                if (node.image.size !== size || graphic) {\r\n                    var image = node.getImageDOM(), box = image.getBBox(), height = size, width = box.width * height / box.height, y = -(height + node.dimensions.height / 2 + 5), x = -width / 2;\r\n                    image.setAttribute(\"height\", height.toString());\r\n                    image.setAttribute(\"width\", width.toString());\r\n                    image.setAttribute(\"y\", y.toString());\r\n                    image.setAttribute(\"x\", x.toString());\r\n                    if (graphic === false) {\r\n                        node.image.size = height;\r\n                    }\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            else\r\n                Log.error(\"The node does not have an image\");\r\n        };\r\n        /**\r\n         * Update the node image src with a new value.\r\n         * @param {Node} node\r\n         * @param {string} src\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeImageSrc = function (node, src) {\r\n            if (src && typeof src !== \"string\") {\r\n                Log.error(\"The image path must be a string\", \"type\");\r\n            }\r\n            if (node.image.src !== src) {\r\n                node.image.src = src;\r\n                _this.map.draw.setImage(node);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Update the node font style.\r\n         * @param {Node} node\r\n         * @param {string} style\r\n         * @param {boolean} graphic\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeFontStyle = function (node, style, graphic) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (style && typeof style !== \"string\") {\r\n                Log.error(\"The font style must be a string\", \"type\");\r\n            }\r\n            if (node.font.style !== style) {\r\n                node.getNameDOM().style[\"font-style\"] = style;\r\n                if (graphic === false) {\r\n                    node.font.style = style;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Update the node font weight.\r\n         * @param {Node} node\r\n         * @param {string} weight\r\n         * @param {boolean} graphic\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeFontWeight = function (node, weight, graphic) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (weight && typeof weight !== \"string\") {\r\n                Log.error(\"The font weight must be a string\", \"type\");\r\n            }\r\n            if (node.font.weight !== weight) {\r\n                node.getNameDOM().style[\"font-weight\"] = weight;\r\n                _this.map.draw.updateNodeShapes(node);\r\n                if (graphic === false) {\r\n                    node.font.weight = weight;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Update the node text decoration.\r\n         * @param {Node} node\r\n         * @param {string} decoration\r\n         * @param {boolean} graphic\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeTextDecoration = function (node, decoration, graphic) {\r\n            if (graphic === void 0) { graphic = false; }\r\n            if (decoration && typeof decoration !== \"string\") {\r\n                Log.error(\"The text decoration must be a string\", \"type\");\r\n            }\r\n            if (node.font.decoration !== decoration) {\r\n                node.getNameDOM().style[\"text-decoration\"] = decoration;\r\n                _this.map.draw.updateNodeShapes(node);\r\n                if (graphic === false) {\r\n                    node.font.decoration = decoration;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Update the node locked status.\r\n         * @param {Node} node\r\n         * @param {boolean} flag\r\n         * @returns {boolean}\r\n         */\r\n        this.updateNodeLockedStatus = function (node, flag) {\r\n            if (flag && typeof flag !== \"boolean\") {\r\n                Log.error(\"The node locked status must be a boolean\", \"type\");\r\n            }\r\n            if (!node.isRoot()) {\r\n                node.locked = flag || !node.locked;\r\n            }\r\n            else {\r\n                Log.error(\"The root node can not be locked\");\r\n            }\r\n        };\r\n        this.map = map;\r\n        this.counter = 0;\r\n        this.nodes = d3.map();\r\n    }\r\n    /**\r\n     * Add the root node to the map.\r\n     * @param {Coordinates} coordinates\r\n     */\r\n    Nodes.prototype.addRootNode = function (coordinates) {\r\n        var properties = Utils.mergeObjects(this.map.options.rootNode, {\r\n            coordinates: {\r\n                x: this.map.dom.container.node().clientWidth / 2,\r\n                y: this.map.dom.container.node().clientHeight / 2\r\n            },\r\n            locked: false,\r\n            id: this.map.id + \"_node_\" + this.counter,\r\n            parent: null\r\n        });\r\n        var node = new Node(properties);\r\n        if (coordinates) {\r\n            node.coordinates.x = coordinates.x || node.coordinates.x;\r\n            node.coordinates.y = coordinates.y || node.coordinates.y;\r\n        }\r\n        this.nodes.set(properties.id, node);\r\n        this.counter++;\r\n        this.map.draw.update();\r\n        this.selectRootNode();\r\n    };\r\n    /**\r\n     * Return the export properties of the node.\r\n     * @param {Node} node\r\n     * @param {boolean} fixedCoordinates\r\n     * @returns {ExportNodeProperties} properties\r\n     */\r\n    Nodes.prototype.getNodeProperties = function (node, fixedCoordinates) {\r\n        if (fixedCoordinates === void 0) { fixedCoordinates = true; }\r\n        return {\r\n            id: node.id,\r\n            parent: node.parent ? node.parent.id : \"\",\r\n            name: node.name,\r\n            coordinates: fixedCoordinates\r\n                ? this.fixCoordinates(node.coordinates, true)\r\n                : Utils.cloneObject(node.coordinates),\r\n            image: Utils.cloneObject(node.image),\r\n            colors: Utils.cloneObject(node.colors),\r\n            font: Utils.cloneObject(node.font),\r\n            locked: node.locked,\r\n            k: node.k\r\n        };\r\n    };\r\n    /**\r\n     * Convert external coordinates to internal or otherwise.\r\n     * @param {Coordinates} coordinates\r\n     * @param {boolean} reverse\r\n     * @returns {Coordinates}\r\n     */\r\n    Nodes.prototype.fixCoordinates = function (coordinates, reverse) {\r\n        if (reverse === void 0) { reverse = false; }\r\n        var zoomCoordinates = d3.zoomTransform(this.map.dom.svg.node()), fixedCoordinates = {};\r\n        if (coordinates.x) {\r\n            if (reverse === false) {\r\n                fixedCoordinates.x = (coordinates.x - zoomCoordinates.x) / zoomCoordinates.k;\r\n            }\r\n            else {\r\n                fixedCoordinates.x = coordinates.x * zoomCoordinates.k + zoomCoordinates.x;\r\n            }\r\n        }\r\n        if (coordinates.y) {\r\n            if (reverse === false) {\r\n                fixedCoordinates.y = (coordinates.y - zoomCoordinates.y) / zoomCoordinates.k;\r\n            }\r\n            else {\r\n                fixedCoordinates.y = coordinates.y * zoomCoordinates.k + zoomCoordinates.y;\r\n            }\r\n        }\r\n        return fixedCoordinates;\r\n    };\r\n    /**\r\n     * Move the node selection in the direction passed as parameter.\r\n     * @param {string} direction\r\n     * @returns {boolean}\r\n     */\r\n    Nodes.prototype.nodeSelectionTo = function (direction) {\r\n        switch (direction) {\r\n            case \"up\":\r\n                this.moveSelectionOnLevel(true);\r\n                return true;\r\n            case \"down\":\r\n                this.moveSelectionOnLevel(false);\r\n                return true;\r\n            case \"left\":\r\n                this.moveSelectionOnBranch(true);\r\n                return true;\r\n            case \"right\":\r\n                this.moveSelectionOnBranch(false);\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    ;\r\n    /**\r\n     * Return the children of a node.\r\n     * @param {Node} node\r\n     * @returns {Node[]}\r\n     */\r\n    Nodes.prototype.getChildren = function (node) {\r\n        return this.nodes.values().filter(function (n) {\r\n            return n.parent && n.parent.id === node.id;\r\n        });\r\n    };\r\n    /**\r\n     * Return the orientation of a node in the map (true if left).\r\n     * @return {boolean}\r\n     */\r\n    Nodes.prototype.getOrientation = function (node) {\r\n        if (!node.isRoot()) {\r\n            return node.coordinates.x < this.getRoot().coordinates.x;\r\n        }\r\n    };\r\n    /**\r\n     * Return the root node.\r\n     * @returns {Node} rootNode\r\n     */\r\n    Nodes.prototype.getRoot = function () {\r\n        return this.nodes.get(this.map.id + \"_node_0\");\r\n    };\r\n    /**\r\n     * Return all descendants of a node.\r\n     * @returns {Node[]} nodes\r\n     */\r\n    Nodes.prototype.getDescendants = function (node) {\r\n        var _this = this;\r\n        var nodes = [];\r\n        this.getChildren(node).forEach(function (node) {\r\n            nodes.push(node);\r\n            nodes = nodes.concat(_this.getDescendants(node));\r\n        });\r\n        return nodes;\r\n    };\r\n    /**\r\n     * Return an array of all nodes.\r\n     * @returns {Node[]}\r\n     */\r\n    Nodes.prototype.getNodes = function () {\r\n        return this.nodes.values();\r\n    };\r\n    /**\r\n     * Return the node with the id equal to id passed as parameter.\r\n     * @param {string} id\r\n     * @returns {Node}\r\n     */\r\n    Nodes.prototype.getNode = function (id) {\r\n        return this.nodes.get(id);\r\n    };\r\n    /**\r\n     * Set a node as a id-value copy.\r\n     * @param {string} key\r\n     * @param {Node} node\r\n     */\r\n    Nodes.prototype.setNode = function (key, node) {\r\n        this.nodes.set(key, node);\r\n    };\r\n    /**\r\n     * Get the counter number of the nodes.\r\n     * @returns {number} counter\r\n     */\r\n    Nodes.prototype.getCounter = function () {\r\n        return this.counter;\r\n    };\r\n    /**\r\n     * Set the counter of the nodes.\r\n     * @param {number} number\r\n     */\r\n    Nodes.prototype.setCounter = function (number) {\r\n        this.counter = number;\r\n    };\r\n    /**\r\n     * Return the current selected node.\r\n     * @returns {Node}\r\n     */\r\n    Nodes.prototype.getSelectedNode = function () {\r\n        return this.selectedNode;\r\n    };\r\n    /**\r\n     * Set the root node as selected node.\r\n     */\r\n    Nodes.prototype.selectRootNode = function () {\r\n        this.selectedNode = this.nodes.get(this.map.id + \"_node_0\");\r\n    };\r\n    /**\r\n     * Delete all nodes.\r\n     */\r\n    Nodes.prototype.clear = function () {\r\n        this.nodes.clear();\r\n    };\r\n    /**\r\n     * Return the siblings of a node.\r\n     * @param {Node} node\r\n     * @returns {Array<Node>} siblings\r\n     */\r\n    Nodes.prototype.getSiblings = function (node) {\r\n        if (!node.isRoot()) {\r\n            var parentChildren = this.getChildren(node.parent);\r\n            if (parentChildren.length > 1) {\r\n                parentChildren.splice(parentChildren.indexOf(node), 1);\r\n                return parentChildren;\r\n            }\r\n            else {\r\n                return [];\r\n            }\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    };\r\n    /**\r\n     * Return the appropriate coordinates of the node.\r\n     * @param {Node} node\r\n     * @returns {Coordinates} coordinates\r\n     */\r\n    Nodes.prototype.calculateCoordinates = function (node) {\r\n        var coordinates = {\r\n            x: node.parent.coordinates.x,\r\n            y: node.parent.coordinates.y\r\n        }, siblings = this.getSiblings(node);\r\n        if (node.parent.isRoot()) {\r\n            var rightNodes = [], leftNodes = [];\r\n            for (var _i = 0, siblings_1 = siblings; _i < siblings_1.length; _i++) {\r\n                var sibling = siblings_1[_i];\r\n                this.getOrientation(sibling) ? leftNodes.push(sibling) : rightNodes.push(sibling);\r\n            }\r\n            if (leftNodes.length <= rightNodes.length) {\r\n                coordinates.x -= 200;\r\n                siblings = leftNodes;\r\n            }\r\n            else {\r\n                coordinates.x += 200;\r\n                siblings = rightNodes;\r\n            }\r\n        }\r\n        else {\r\n            if (this.getOrientation(node.parent)) {\r\n                coordinates.x -= 200;\r\n            }\r\n            else {\r\n                coordinates.x += 200;\r\n            }\r\n        }\r\n        if (siblings.length > 0) {\r\n            var lowerNode = this.getLowerNode(siblings);\r\n            coordinates.y = lowerNode.coordinates.y + 60;\r\n        }\r\n        else {\r\n            coordinates.y -= 120;\r\n        }\r\n        return coordinates;\r\n    };\r\n    /**\r\n     * Return the lower node of a list of nodes.\r\n     * @param {Node[]} nodes\r\n     * @returns {Node} lowerNode\r\n     */\r\n    Nodes.prototype.getLowerNode = function (nodes) {\r\n        if (nodes === void 0) { nodes = this.nodes.values(); }\r\n        if (nodes.length > 0) {\r\n            var tmp = nodes[0].coordinates.y, lowerNode = nodes[0];\r\n            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\r\n                var node = nodes_1[_i];\r\n                if (node.coordinates.y > tmp) {\r\n                    tmp = node.coordinates.y;\r\n                    lowerNode = node;\r\n                }\r\n            }\r\n            return lowerNode;\r\n        }\r\n    };\r\n    /**\r\n     * Move the node selection on the level of the current node (true: up).\r\n     * @param {boolean} direction\r\n     */\r\n    Nodes.prototype.moveSelectionOnLevel = function (direction) {\r\n        var _this = this;\r\n        if (!this.selectedNode.isRoot()) {\r\n            var siblings = this.getSiblings(this.selectedNode).filter(function (node) {\r\n                return direction === node.coordinates.y < _this.selectedNode.coordinates.y;\r\n            });\r\n            if (this.selectedNode.parent.isRoot()) {\r\n                siblings = siblings.filter(function (node) {\r\n                    return _this.getOrientation(node) === _this.getOrientation(_this.selectedNode);\r\n                });\r\n            }\r\n            if (siblings.length > 0) {\r\n                var closerNode = siblings[0], tmp = Math.abs(siblings[0].coordinates.y - this.selectedNode.coordinates.y);\r\n                for (var _i = 0, siblings_2 = siblings; _i < siblings_2.length; _i++) {\r\n                    var node = siblings_2[_i];\r\n                    var distance = Math.abs(node.coordinates.y - this.selectedNode.coordinates.y);\r\n                    if (distance < tmp) {\r\n                        tmp = distance;\r\n                        closerNode = node;\r\n                    }\r\n                }\r\n                this.selectNode(closerNode.id);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Move the node selection in a child node or in the parent node (true: left)\r\n     * @param {boolean} direction\r\n     */\r\n    Nodes.prototype.moveSelectionOnBranch = function (direction) {\r\n        var _this = this;\r\n        if ((this.getOrientation(this.selectedNode) === false && direction) ||\r\n            (this.getOrientation(this.selectedNode) === true && !direction)) {\r\n            this.selectNode(this.selectedNode.parent.id);\r\n        }\r\n        else {\r\n            var children = this.getChildren(this.selectedNode);\r\n            if (this.getOrientation(this.selectedNode) === undefined) {\r\n                // The selected node is the root\r\n                children = children.filter(function (node) {\r\n                    return _this.getOrientation(node) === direction;\r\n                });\r\n            }\r\n            var lowerNode = this.getLowerNode(children);\r\n            if (children.length > 0) {\r\n                this.selectNode(lowerNode.id);\r\n            }\r\n        }\r\n    };\r\n    return Nodes;\r\n}());\r\nexport default Nodes;\r\n"}
